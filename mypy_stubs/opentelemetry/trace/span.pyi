import abc
import types as python_types
import typing
from opentelemetry.trace.status import Status as Status
from opentelemetry import types as types
from typing import Any

class Span(abc.ABC, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def end(self, end_time: typing.Optional[int] = ...) -> None: ...
    @abc.abstractmethod
    def get_span_context(self) -> SpanContext: ...
    @abc.abstractmethod
    def set_attributes(
        self, attributes: typing.Dict[str, types.AttributeValue]
    ) -> None: ...
    @abc.abstractmethod
    def set_attribute(self, key: str, value: types.AttributeValue) -> None: ...
    @abc.abstractmethod
    def add_event(
        self,
        name: str,
        attributes: types.Attributes = ...,
        timestamp: typing.Optional[int] = ...,
    ) -> None: ...
    @abc.abstractmethod
    def update_name(self, name: str) -> None: ...
    @abc.abstractmethod
    def is_recording(self) -> bool: ...
    @abc.abstractmethod
    def set_status(self, status: Status) -> None: ...
    @abc.abstractmethod
    def record_exception(
        self,
        exception: Exception,
        attributes: types.Attributes = ...,
        timestamp: typing.Optional[int] = ...,
        escaped: bool = ...,
    ) -> None: ...
    def __enter__(self) -> Span: ...
    def __exit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[python_types.TracebackType],
    ) -> None: ...

class TraceFlags(int):
    DEFAULT: int
    SAMPLED: int
    @classmethod
    def get_default(cls) -> TraceFlags: ...
    @property
    def sampled(self) -> bool: ...

DEFAULT_TRACE_OPTIONS: Any

class TraceState(typing.Mapping[str, str]):
    def __init__(
        self, entries: typing.Optional[typing.Sequence[typing.Tuple[str, str]]] = ...
    ) -> None: ...
    def __contains__(self, item: object) -> bool: ...
    def __getitem__(self, key: str) -> str: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def add(self, key: str, value: str) -> TraceState: ...
    def update(self, key: str, value: str) -> TraceState: ...
    def delete(self, key: str) -> TraceState: ...
    def to_header(self) -> str: ...
    @classmethod
    def from_header(cls, header_list: typing.List[str]) -> TraceState: ...
    @classmethod
    def get_default(cls) -> TraceState: ...
    def keys(self) -> typing.KeysView[str]: ...
    def items(self) -> typing.ItemsView[str, str]: ...
    def values(self) -> typing.ValuesView[str]: ...

DEFAULT_TRACE_STATE: Any

class SpanContext(typing.Tuple[int, int, bool, "TraceFlags", "TraceState", bool]):
    def __new__(
        cls,
        trace_id: int,
        span_id: int,
        is_remote: bool,
        trace_flags: typing.Optional["TraceFlags"] = ...,
        trace_state: typing.Optional["TraceState"] = ...,
    ) -> SpanContext: ...
    def __getnewargs__(
        self,
    ) -> typing.Tuple[int, int, bool, "TraceFlags", "TraceState"]: ...
    @property
    def trace_id(self) -> int: ...
    @property
    def span_id(self) -> int: ...
    @property
    def is_remote(self) -> bool: ...
    @property
    def trace_flags(self) -> TraceFlags: ...
    @property
    def trace_state(self) -> TraceState: ...
    @property
    def is_valid(self) -> bool: ...
    def __setattr__(self, *args: str) -> None: ...
    def __delattr__(self, *args: str) -> None: ...

class NonRecordingSpan(Span):
    def __init__(self, context: SpanContext) -> None: ...
    def get_span_context(self) -> SpanContext: ...
    def is_recording(self) -> bool: ...
    def end(self, end_time: typing.Optional[int] = ...) -> None: ...
    def set_attributes(
        self, attributes: typing.Dict[str, types.AttributeValue]
    ) -> None: ...
    def set_attribute(self, key: str, value: types.AttributeValue) -> None: ...
    def add_event(
        self,
        name: str,
        attributes: types.Attributes = ...,
        timestamp: typing.Optional[int] = ...,
    ) -> None: ...
    def update_name(self, name: str) -> None: ...
    def set_status(self, status: Status) -> None: ...
    def record_exception(
        self,
        exception: Exception,
        attributes: types.Attributes = ...,
        timestamp: typing.Optional[int] = ...,
        escaped: bool = ...,
    ) -> None: ...

INVALID_SPAN_ID: int
INVALID_TRACE_ID: int
INVALID_SPAN_CONTEXT: Any
INVALID_SPAN: Any

def format_trace_id(trace_id: int) -> str: ...
def format_span_id(span_id: int) -> str: ...
